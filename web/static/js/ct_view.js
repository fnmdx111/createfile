// Generated by CoffeeScript 1.7.1
(function() {
  var __slice = [].slice;

  Flotr.addType('ct_view', {
    options: {
      show: false,
      lineWidth: 2,
      barWidth: 1,
      fill: true,
      fillColor: null,
      fillOpacity: 0.4,
      horizontal: false,
      centered: true,
      realData: _.identity,
      topPadding: 0.1
    },
    draw: function(options) {
      var context;
      context = options.context;
      this.current += 1;
      context.save();
      context.lineJoin = 'miter';
      context.lineWidth = options.lineWidth;
      context.strokeStyle = options.color;
      if (options.fill) {
        context.fillStyle = options.fillStyle;
      }
      this.plot(options);
      return context.restore();
    },
    plot: function(options) {
      var cl_segment, cl_segments, context, d, d_, data, geometry, height, left, shadowSize, top, width, x, _i, _len, _results;
      data = options.data;
      context = options.context;
      shadowSize = options.shadowSize;
      if (data.length < 1) {
        return;
      }
      this.translate(context, options.horizontal);
      _results = [];
      for (_i = 0, _len = data.length; _i < _len; _i++) {
        d_ = data[_i];
        d = options.realData(d_);
        x = d[0], cl_segments = 2 <= d.length ? __slice.call(d, 1) : [];
        _results.push((function() {
          var _j, _len1, _ref, _results1;
          _results1 = [];
          for (_j = 0, _len1 = cl_segments.length; _j < _len1; _j++) {
            cl_segment = cl_segments[_j];
            geometry = this.getBarGeometry(x, cl_segment, options);
            if (geometry === null) {
              continue;
            }
            _ref = [geometry.left, geometry.top, geometry.width, geometry.height], left = _ref[0], top = _ref[1], width = _ref[2], height = _ref[3];
            if (options.fill) {
              context.fillRect(left, top, width, height);
            }
            if (shadowSize) {
              context.save();
              context.fillStyle = 'rgba(0, 0, 0, 0.05)';
              context.fillRect(left + shadowSize, top + shadowSize, width, height);
              context.restore();
            }
            if (options.lineWidth) {
              _results1.push(context.strokeRect(left, top, width, height));
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        }).call(this));
      }
      return _results;
    },
    translate: function(context, horizontal) {
      if (horizontal) {
        context.rotate(-Math.PI / 2);
        return context.scale(-1, 1);
      }
    },
    getBarGeometry: function(x, y, options) {
      var barWidth, bisection, bottom, height, horizontal, left, lineWidth, right, scaled_x, top, xScale, xValue, yScale, yValue, yeValue, ysValue;
      barWidth = options.barWidth;
      bisection = options.centered ? barWidth / 2 : 0;
      horizontal = options.horizontal;
      xScale = horizontal ? options.yScale : options.xScale;
      yScale = horizontal ? options.xScale : options.yScale;
      xValue = horizontal ? y : x;
      yValue = horizontal ? x : y;
      ysValue = yValue[0], yeValue = yValue[1];
      scaled_x = (xScale(xValue)) - bisection;
      left = scaled_x;
      right = scaled_x + barWidth;
      top = yScale(yeValue);
      bottom = yScale(ysValue);
      if (bottom < 0) {
        bottom = 0;
      }
      height = bottom - top;
      lineWidth = options.lineWidth;
      if (x === null || y === null) {
        return null;
      } else {
        return {
          x: xValue,
          y: yValue,
          xScale: xScale,
          yScale: yScale,
          top: top,
          left: Math.min(left, right) - lineWidth / 2,
          width: Math.abs(right - left) - lineWidth,
          height: height > 0 ? height : 0.7
        };
      }
    },
    hit: function(options) {
      var d, data, geometry, height, hitGeometry, i, left, mouse, n, width, x, y, _ref, _results;
      data = options.data;
      _ref = options.args, mouse = _ref[0], n = _ref[1];
      x = options.xInverse(mouse.relX);
      y = options.yInverse(mouse.relY);
      hitGeometry = this.getBarGeometry(x, y, options);
      width = hitGeometry.width / 2;
      left = hitGeometry.left;
      height = hitGeometry.y;
      i = data.length;
      _results = [];
      while (i--) {
        d = options.realData(data[i]);
        geometry = this.getBarGeometry(d[0], d[1], options);
        if (((geometry.y[0] < height && height < geometry.y[1]) || (geometry.y[0] > height && height > geometry.y[1])) && Math.abs(left - geometry.left) < width) {
          n.x = d[0], n.y = d[1];
          n.index = i;
          _results.push(n.seriesIndex = options.index);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    },
    drawHit: function(options) {
      var args, context, geometry, height, left, top, width, _ref;
      context = options.context;
      args = options.args;
      geometry = this.getBarGeometry(args.x, args.y, options);
      _ref = [geometry.left, geometry.top, geometry.width, geometry.height], left = _ref[0], top = _ref[1], width = _ref[2], height = _ref[3];
      context.save();
      context.strokeStyle = options.color;
      context.lineWidth = options.lineWidth;
      this.translate(context, options.horizontal);
      context.beginPath();
      context.moveTo(left, top + height);
      context.lineTo(left, top);
      context.lineTo(left + width, top);
      context.lineTo(left + width, top + height);
      context.lineTo(left, top + height);
      if (options.fill) {
        context.fillStyle = options.fillStyle;
        context.fill();
      }
      context.stroke();
      context.closePath();
      return context.restore();
    },
    clearHit: function(options) {
      var args, context, geometry, height, left, lineWidth, top, width, _ref;
      context = options.context;
      args = options.args;
      geometry = this.getBarGeometry(args.x, args.y, options);
      _ref = [geometry.left, geometry.top, geometry.width, geometry.height], left = _ref[0], top = _ref[1], width = _ref[2], height = _ref[3];
      lineWidth = 2 * options.lineWidth;
      context.save();
      this.translate(context, options.horizontal);
      context.clearRect(left - lineWidth, Math.min(top, top + height) - lineWidth, width + 2 * lineWidth, Math.abs(height) + 2 * lineWidth);
      return context.restore();
    }
  });

}).call(this);

//# sourceMappingURL=ct_view.map
